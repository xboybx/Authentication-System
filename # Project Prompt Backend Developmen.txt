# Project Prompt: Backend Development - Authentication APIs with Refresh Token

## Project Overview
Create a secure, production-ready authentication system using Node.js and Express.js with JWT (JSON Web Tokens) for access and refresh tokens. The project must emphasize security best practices, scalable architecture, and proper error handling.

## Technology Stack
- **Runtime**: Node.js
- **Framework**: Express.js
- **Authentication**: JWT (jsonwebtoken library)
- **Password Security**: bcrypt
- **Database**: MongoDB with Mongoose ORM
- **Validation**: express-validator
- **Security**: helmet, cors
- **Environment Management**: dotenv

## Project Objectives

### 1. Registration API
- Create an endpoint that accepts user details (email, password, name, etc.)
- Hash passwords using bcrypt before storing (minimum 10 salt rounds)
- Validate all input fields (email format, password strength, required fields)
- Store user details securely in MongoDB
- Return appropriate success/error responses
- Prevent duplicate email registrations

### 2. Login API
- Create an endpoint that authenticates users with email and password
- Verify hashed passwords using bcrypt
- Generate TWO tokens upon successful authentication:
  - **Access Token**: Short-lived (15 minutes), used for API requests
  - **Refresh Token**: Long-lived (7 days), used to generate new access tokens
- Return both tokens to the client
- Handle invalid credentials with proper error messages

### 3. Refresh Token Mechanism
- Create an endpoint that accepts a refresh token
- Validate the refresh token's authenticity and expiration
- Generate a new access token without requiring re-login
- Implement refresh token rotation (optional but recommended)
- Store refresh tokens securely (in database or Redis)
- Invalidate old refresh tokens when new ones are issued

### 4. Token Expiration Management
- Set appropriate expiration times:
  - Access Token: 15 minutes (adjustable)
  - Refresh Token: 7 days (adjustable)
- Include expiration information in JWT payload
- Handle expired tokens with specific error codes
- Provide clear error messages for token expiration

### 5. Validation & Error Handling
- Validate all request inputs (body, params, query)
- Implement input sanitization to prevent injection attacks
- Use express validator for schema validation
- Create a global error handling middleware
- Return consistent error response format:
  ```json
  {
    "success": false,
    "message": "Error description",
    "error": "Error code or type"
  }
  ```
- Wrap all async operations in try/catch blocks
- Log errors appropriately without exposing sensitive data

### 6. Security Best Practices

#### Password Security
- Hash passwords with bcrypt (minimum 10 rounds)
- Never store plain text passwords
- Implement password strength requirements (minimum 8 characters, mix of letters, numbers, symbols)

#### JWT Security
- Sign tokens with strong secret keys stored in environment variables
- Use different secrets for access and refresh tokens
- Include relevant claims (user ID, role, issued at, expiration)
- Verify token signatures on protected routes

#### HTTP Security
- Implement helmet middleware for security headers
- Configure CORS properly (whitelist allowed origins)
- Use HTTPS in production
- Implement rate limiting on authentication endpoints
- Set secure, httpOnly cookies if storing tokens in cookies

#### Input Validation
- Validate all user inputs before processing
- Sanitize data to prevent XSS attacks
- Use parameterized queries (Mongoose handles this)
- Implement request size limits

## Expected Deliverables

### 1. API Endpoints
```
POST /api/auth/register - User registration
POST /api/auth/login - User login
POST /api/auth/refresh - Refresh access token
POST /api/auth/logout - Invalidate refresh token (optional)
GET /api/auth/profile - Protected route example (requires access token)
```

└── server.js
```


### 4. Secure Token Storage
- Store refresh tokens in database with:
  - User reference
  - Token hash or ID
  - Expiration date
  - Created date
  - Device/IP information (optional)
- Implement token cleanup for expired tokens

## Node.js Backend Best Practices to Implement

### 1. Error Handling & Stability
- Always wrap async calls in try/catch blocks
- Create a global error handler middleware
- Return consistent error responses with proper HTTP status codes
- Never expose internal error details to clients
- Log errors for debugging without sensitive information

### 2. Environment Configuration
- Store ALL secrets in .env file (DB URLs, JWT secrets, API keys)
- Never hardcode credentials in code
- Provide .env.example file with dummy values
- Use different configurations for development, testing, and production

### 3. Request Validation
- Validate request body, params, and query using Joi or Zod
- Prevent malicious or invalid data from reaching database
- Return clear validation error messages
- Implement whitelist approach (only accept expected fields)

### 4. Security Practices
- Use helmet middleware for HTTP security headers
- Configure CORS properly (don't use wildcard in production)
- Implement rate limiting on authentication endpoints
- Sanitize user inputs to prevent XSS and injection attacks
- Use HTTPS in production
- Implement CSRF protection if using cookies

### 5. Logging & Monitoring
- Implement structured logging (Winston or Pino)
- Track errors and performance metrics
- Log authentication attempts (successful and failed)
- Monitor token generation and refresh patterns
- Set up alerts for suspicious activities

### 6. Folder Structure & Modularity
- Separate routes, controllers, services, and models
- Follow Single Responsibility Principle (SRP) for each file
- Keep business logic in services, not controllers
- Controllers should only handle request/response
- Models should only define schema and instance methods

### 7. Database & Query Safety
- Use Mongoose ORM for MongoDB
- Define proper schemas with validation
- Always use parameterized queries (Mongoose does this automatically)
- Index frequently queried fields (email, userId)
- Implement soft delete for user accounts

### 8. Performance Optimization
- Avoid blocking the event loop with heavy synchronous tasks
- Use async/await properly
- Implement database connection pooling
- Cache frequently accessed data (optional: use Redis)
- Minimize middleware stack for performance

### 9. Graceful Shutdown
- Handle SIGTERM and SIGINT signals
- Close database connections properly
- Finish processing existing requests
- Prevent new requests during shutdown
- Clean up resources and connections

ntication events